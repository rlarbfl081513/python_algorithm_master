# [Silver II] 좌표 압축 - 18870 

[문제 링크](https://www.acmicpc.net/problem/18870) 

### 성능 요약

메모리: 159312 KB, 시간: 1560 ms

### 분류

정렬, 값 / 좌표 압축

### 제출 일자

2026년 2월 11일 09:17:43

### 문제 설명

<p>수직선 위에 N개의 좌표 X<sub>1</sub>, X<sub>2</sub>, ..., X<sub>N</sub>이 있다. 이 좌표에 좌표 압축을 적용하려고 한다.</p>

<p>X<sub>i</sub>를 좌표 압축한 결과 X'<sub>i</sub>의 값은 X<sub>i</sub> > X<sub>j</sub>를 만족하는 서로 다른 좌표 X<sub>j</sub>의 개수와 같아야 한다.</p>

<p>X<sub>1</sub>, X<sub>2</sub>, ..., X<sub>N</sub>에 좌표 압축을 적용한 결과 X'<sub>1</sub>, X'<sub>2</sub>, ..., X'<sub>N</sub>를 출력해보자.</p>

### 입력 

 <p>첫째 줄에 N이 주어진다.</p>

<p>둘째 줄에는 공백 한 칸으로 구분된 X<sub>1</sub>, X<sub>2</sub>, ..., X<sub>N</sub>이 주어진다.</p>

### 출력 

 <p>첫째 줄에 X'<sub>1</sub>, X'<sub>2</sub>, ..., X'<sub>N</sub>을 공백 한 칸으로 구분해서 출력한다.</p>

---

# 풀이
## 파이썬 리스트 탐색과 좌표 압축 알고리즘 성능 비교 분석

### 1. 방법 1: 중첩 반복문을 이용한 탐색 (시간 초과 발생)

#### 구조 분석

* 외부에서 리스트를 순회하며 각 원소마다 `box` 함수를 호출함
* `box` 함수 내부에서 다시 전체 리스트(`arr`)를 순회하는 **이중 반복문** 구조임
* `if j not in new` 구문은 리스트 `new`를 처음부터 끝까지 탐색하므로 내부적으로 **추가적인 반복**이 발생함

#### 성능 특징

* **시간 복잡도:**  이상의 비용 발생
* 데이터 개수가 일 때, 연산 횟수가 의 제곱에 비례하여 급격히 증가함
* 입력 데이터가 10,000개만 되어도 약 1억 번 이상의 연산이 필요하여 일반적인 제한 시간(1~2초) 내에 해결 불가능함

---

### 2. 방법 2: 정렬과 해시 맵을 이용한 최적화 (통과)

#### 구조 분석

1. **`set(arr)`**: 중복된 원소를 제거함
2. **`new.sort()`**: 중복이 제거된 원소들을 크기순으로 정렬함
3. **`dic` 생성**: 정렬된 리스트를 순회하며 `{값: 인덱스}` 형태의 딕셔너리를 구축함
4. **최종 출력**: 원본 리스트를 순회하며 딕셔너리에서 즉시 값을 찾아 출력함

#### 성능 특징

* **시간 복잡도:** 
* 정렬 과정()이 전체 시간을 결정하며, 딕셔너리 생성 및 조회는 매우 빠름
* 데이터가 많아질수록 방법 1과 비교할 수 없을 정도로 빠른 성능을 보임

---

### 3. Set, Sort, Dict가 빠른 이유

#### Set (중복 제거)

* 리스트는 특정 원소를 찾기 위해 처음부터 끝까지 순차적으로 확인해야 함 ()
* 세트는 **해시 테이블(Hash Table)** 구조를 사용함. 값이 들어올 위치를 수학적으로 계산하여 바로 접근하므로 중복 확인 및 삽입이 매우 빠름 ()

#### Sort (정렬)

* 파이썬의 `sort`는 Timsort 알고리즘을 사용함. 최악의 경우에도 $O(N \log N)$의 속도를 보장하도록 고도로 최적화되어 있음
* 무작위 데이터를 전수 조사하는 것보다 한 번 정렬한 뒤 규칙(인덱스)을 찾는 것이 효율적임

#### Dict (딕셔너리 조회)

* 딕셔너리 역시 세트와 마찬가지로 해시 테이블을 기반으로 작동함
* `dic[j]`를 호출할 때 리스트처럼 전체를 훑는 것이 아니라, 키(Key) 값을 통해 메모리 주소로 직접 점프함
* 조회 속도가 데이터 양에 관계없이 일정함 ()

---

### 요약 비교 테이블

| 항목 | 방법 1 (리스트 기반) | 방법 2 (Set/Sort/Dict 기반) |
| --- | --- | --- |
| **주요 전략** | 매번 전수 조사 | 정렬 후 해시 조회 |
| **시간 복잡도** |  |  |
| **데이터 10만 개 처리** | 불가능 (수십 시간 소요 예상) | 가능 (1초 미만 소요) |
| **효율성** | 매우 낮음 | 매우 높음 |
