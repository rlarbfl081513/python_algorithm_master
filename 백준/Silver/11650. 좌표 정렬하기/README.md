# [Silver V] 좌표 정렬하기 - 11650 

[문제 링크](https://www.acmicpc.net/problem/11650) 

### 성능 요약

메모리: 52648 KB, 시간: 320 ms

### 분류

정렬

### 제출 일자

2026년 2월 10일 10:00:45

### 문제 설명

<p>2차원 평면 위의 점 N개가 주어진다. 좌표를 x좌표가 증가하는 순으로, x좌표가 같으면 y좌표가 증가하는 순서로 정렬한 다음 출력하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 점의 개수 N (1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N개의 줄에는 i번점의 위치 x<sub>i</sub>와 y<sub>i</sub>가 주어진다. (-100,000 ≤ x<sub>i</sub>, y<sub>i</sub> ≤ 100,000) 좌표는 항상 정수이고, 위치가 같은 두 점은 없다.</p>

### 출력 

 <p>첫째 줄부터 N개의 줄에 점을 정렬한 결과를 출력한다.</p>

---

# [풀이방식]
첫번째 풀이방식
```python
n = int(input())
arr = list(list(map(int,input().split(" "))) for _ in range(n))
arr.sort()

for i in arr:
    print(i[0],i[1])

```
위 방식은 정답이기는하나 **2804ms**라는 시간이 걸림. 보통 이 문제의 Python 정답자들이 **400ms ~ 800ms** 정도 나오는 것과 비교하면 꽤 차이가 남.

로직(정렬 알고리즘) 자체는 파이썬의 `sort()`가 $O(N \log N)$으로 매우 빠르기 때문에 문제가 없지만, **'입출력 방식'**에서 병목 현상이 생기고 있음.

---

## 1. `input()` 대신 `sys.stdin.readline` 사용 (필수!)

파이썬의 `input()`은 속도가 매우 느립니다. 이 100,000개나 되는 데이터를 하나씩 `input()`으로 받으면 여기서만 수천 ms가 소요될 수 있어요.

```python
import sys
input = sys.stdin.readline  # 이 한 줄만 추가해도 속도가 비약적으로 빨라집니다.

n = int(input())
# 나머지는 그대로 두셔도 됩니다.

```

## 2. 출력 방식 최적화

`for`문 안에서 매번 `print()`를 호출하는 것도 생각보다 비용이 큽니다. 출력을 하나의 문자열로 모아서 한 번에 내보내면 더 빠릅니다.

---

## 🚀 개선된 코드 (400ms대 예상)

```python
import sys
input = sys.stdin.readline

n = int(input())
arr = []

# 리스트 컴프리헨션보다 append가 가독성이 좋고, 
# 데이터가 많을 땐 sys.stdin.read().split() 등을 활용하기도 합니다.
for _ in range(n):
    arr.append(list(map(int, input().split())))

arr.sort()

# 출력 최적화: 리스트의 각 원소를 문자열로 바꿔 한 번에 출력
for i in arr:
    sys.stdout.write(f"{i[0]} {i[1]}\n")

```

---

## 왜 이렇게 차이가 날까요?

1. **`input()` vs `sys.stdin.readline**`: `input()`은 입력받은 문자열의 끝에서 개행 문자를 제거하고, 프롬프트 메시지를 처리하는 등 부가적인 작업이 많습니다. 반면 `sys` 모듈은 버퍼를 이용해 한꺼번에 읽어오기 때문에 훨씬 빠릅니다.
2. **출력 병목**: `print()`는 호출될 때마다 I/O 리소스를 소모합니다. 이면 10만 번 리소스를 사용하는 셈이죠.

### 💡 추가 팁

현재 `arr.sort()`를 사용하셨는데, 파이썬의 `sort()`는 기본적으로 **첫 번째 인덱스로 정렬하고, 같으면 두 번째 인덱스로 정렬**하는 기능을 내장하고 있습니다. 문제의 요구사항과 정확히 일치해서 지금처럼 쓰시면 됩니다!

----
# `sys.stdout.write()` 뭐지?
아까 사용했던 `print()`와 하는 역할은 똑같지만, **"속도에만 올인한 출력 방법"**이라고 생각하면 쉬워요!

`print()`가 친절하고 다재다능한 비서라면, `sys.stdout.write()`는 말없이 시키는 일만 빠르게 처리하는 공장 기계와 같습니다.

---

### 1. `print()`와 다른 점 3가지

* **자동 줄바꿈이 없어요:** `print()`는 쓰고 나면 자동으로 줄을 바꿔주지만, `write()`는 시키는 대로만 출력합니다. 그래서 맨 뒤에 직접 `\n`(줄바꿈 문자)을 붙여준 거예요.
* **문자열만 받을 수 있어요:** `print(123)`은 숫자를 넣어도 알아서 문자로 바꿔서 출력해주지만, `write()`는 반드시 **문자열** 형태만 넣어야 합니다. 그래서 f-string(`f"{...}"`)을 사용해 숫자를 문자로 감싼 거예요.
* **버퍼링(Buffering) 방식:** `print()`보다 내부적인 처리 과정이 훨씬 단순해서, 데이터가 수만 개일 때는 속도 차이가 엄청나게 납니다.

---

### 2. 코드 뜯어보기

```python
sys.stdout.write(f"{i[0]} {i[1]}\n")

```

1. **`sys.stdout`**: "시스템의 표준 출력(화면)으로 보내겠다"는 뜻입니다.
2. **`.write()`**: "괄호 안의 내용을 화면에 써라"는 명령어입니다.
3. **`f"{i[0]} {i[1]}\n"`**:
* `i[0]`(x좌표)과 `i[1]`(y좌표) 사이에 공백 하나를 두고 출력합니다.
* 맨 끝에 `\n`을 넣어 다음 줄로 넘어가게 만듭니다.



---

### 💡 굳이 이걸 써야 할까요?

사실 평소에는 `print()`가 훨씬 편합니다. 하지만 지금 푸시는 **백준 11650번**처럼 출력해야 할 데이터가 **10만 줄**이나 되는 경우에는 `print()`가 너무 느려서 '시간 초과'를 유발할 수 있음

**더 쉬운 방법**
만약 `write()` 문법이 너무 낯설다면, `print()`를 쓰되 **'조금 더 빠르게'** 출력하는 이 방법

```python
# for문 안에서 print를 계속 하는 대신
# 결과값들을 리스트에 다 담아두고 한꺼번에 합쳐서 한 번만 print!
results = []
for i in arr:
    results.append(f"{i[0]} {i[1]}")

print("\n".join(results))

```

이 방식도 `write()`만큼이나 빠르고 코드가 직관적
