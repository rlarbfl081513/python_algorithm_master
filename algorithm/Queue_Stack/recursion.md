# 재귀

## 문제 : swea 1234 재귀로 푸는 문제
```python
## 올바른 방식
def password(word):
    # 계속해서 앞으로 가다가 방금 것과 똑같은게 나오면 소거시키고 - 다시 확인
    for i in range(len(word)-1):
        if word[i] == word[i+1]:
            word = word[:i] + word[i+1+1:]

            return password(word)
    return word


for tc in range(1,2):
    n,m = map(str,input().split())
    m = list(m)
    print(n,m)
    print(f'#{tc}',"".join(password(m)))

# 잘못된 방식
def password(word):
    # 계속해서 앞으로 가다가 방금 것과 똑같은게 나오면 소거시키고 - 다시 확인
    for i in range(len(word)-1):
        if word[i] == word[i+1]:
            word = word[:i] + word[i+1+1:]
            password(word)
            return word


for tc in range(1,2):
    n,m = map(str,input().split())
    m = list(m)
    print(n,m)
    print(password(m))
```
1. 잘못된 방식 원인
- 재귀호출 password(w)는 그냥 실행만 하고 결과는 버림 (그냥 재귀되도록만 하는 거임) --> 현재 함수가 가지고 있는 word를 리턴함
- 결국, 맨 처음 호출한 함수가 갖고 있던 word가 최종 반환됨 -> 원래 형태로 그대로 돌려주는 것처러 보임
2. 올바른 방식은 왜 올바른 걸까?
- 재귀호출의 결과를 그대로 리턴
- 하위호출이 최종결과를 만들면, 그 값이 계속 상위 호출로 전달됨
- 연쇄적으로 다 올라와서 마지막에 "그때의 결과값"이 반환된다
```
    호출1: password("1223")
    → "22" 제거 → "13"
    → return password("13")

    호출2: password("13")
    → 제거 없음 → return "13"

    호출1은 호출2의 반환값 "13"을 그대로 반환
    최종 결과 = "13"

```

## 후위표기식
1. 계산 방법

**후위 표기식(Postfix Notation, Reverse Polish Notation)** 은 **연산자(operator)를 피연산자 뒤에 쓰는 표기법**이에요.

---

## 1. 일반적인 표기법 (중위 표기식, Infix)

우리가 보통 쓰는 방식:

```
A + B
(3 + 5) * 2
```

👉 연산자가 피연산자 **사이에** 있음.

---

## 2. 후위 표기식 (Postfix)

연산자를 피연산자 **뒤에** 배치:

```
A B +
3 5 + 2 *
```

\= `(3 + 5) * 2`와 같은 의미

---

## 3. 특징

* **괄호가 필요 없음**
  예: `(A + B) * C`

  * 중위: `(A + B) * C`
  * 후위: `A B + C *`
* 계산 순서를 스택(Stack)으로 명확하게 정의 가능
* 컴퓨터가 연산하기 훨씬 쉽다 → 컴파일러나 계산기 내부에서 자주 사용

---

## 4. 계산 방법 (스택 이용)

예: 후위식 `3 4 5 * +`
 중위식 `(3 + (4 * 5))`

1. 피연산자면 스택에 push

   * 3 push → \[3]
   * 4 push → \[3,4]
   * 5 push → \[3,4,5]

2. 연산자 만나면 스택에서 피연산자 2개 꺼내 계산 후 결과 push

   * `*` → 4 \* 5 = 20 → push → \[3,20]
   * `+` → 3 + 20 = 23 → push → \[23]

3. 스택에 남은 값 = 결과 = **23**

---

요약

* **중위 표기식**: A + B (우리가 쓰는 방식)
* **후위 표기식**: A B + (연산자를 뒤에)
* 장점: 괄호 불필요, 스택으로 쉽게 계산 가능 → 컴퓨터/계산기 내부에서 많이 씀

## 5. 예시 및 설명
여기 전체 변환 과정을 **토큰 단위**로 보여줄게요.
규칙 요약: 피연산자→바로 출력, `(`→push, `)`→`(` 나올 때까지 pop→출력, 연산자→스택 top의 연산자가 **우선순위가 크거나 같으면** pop→출력 후 현재 연산자 push. (`*`/`/` > `+`/`-`, `+`는 **좌결합**이라 같은 `+`도 pop)

중위식: `3 + ( 4 + 5 ) * 6 + 7`

| 단계 |  토큰 | 동작                                                                                                               | 스택(top 오른쪽) | 출력(후위)              |
| -: | :-: | ---------------------------------------------------------------------------------------------------------------- | ----------- | ------------------- |
|  1 |  3  | 피연산자 → 출력                                                                                                        |             | `3`                 |
|  2 |  +  | 스택 비어있음 → push                                                                                                   | `+`         | `3`                 |
|  3 |  (  | 괄호 → push                                                                                                        | `+ ( `      | `3`                 |
|  4 |  4  | 피연산자 → 출력                                                                                                        | `+ ( `      | `3 4`               |
|  5 |  +  | top=`(` → 그냥 push                                                                                                | `+ ( +`     | `3 4`               |
|  6 |  5  | 피연산자 → 출력                                                                                                        | `+ ( +`     | `3 4 5`             |
|  7 |  )  | `(`까지 pop → `+` 출력, `(` 제거                                                                                       | `+`         | `3 4 5 +`           |
|  8 |  \* | top=`+` (우선순위 낮음) → `*` push                                                                                     | `+ *`       | `3 4 5 +`           |
|  9 |  6  | 피연산자 → 출력                                                                                                        | `+ *`       | `3 4 5 + 6`         |
| 10 |  +  | top=`*` (높음) → `*` pop→출력 → `3 4 5 + 6 *`<br>이어서 top=`+` (같음, 좌결합) → `+` pop→출력 → `3 4 5 + 6 * +`<br>현재 `+` push | `+`         | `3 4 5 + 6 * +`     |
| 11 |  7  | 피연산자 → 출력                                                                                                        | `+`         | `3 4 5 + 6 * + 7`   |
| 12 |  끝  | 스택 비우기 → `+` 출력                                                                                                  |             | `3 4 5 + 6 * + 7 +` |

즉 최종 후위식은 **`3 4 5 + 6 * + 7 +` (=`345+6*+7+`)** 입니다.

핵심 포인트(질문하신 부분):

* 9→10단계에서 `+`를 만났을 때, 스택 top의 `*`가 **더 높아서** 먼저 출력됩니다.
* 같은 단계에서 이어서 스택 top의 `+`가 **같은 우선순위(좌결합)** 이므로 **그 `+`도 먼저 출력**되고, 그 다음에 **현재 들어온 `+`를 push**합니다.
* 그래서 출력이 `… 6 * +`가 된 뒤에 `7`이 나오고, 마지막에 남은 `+`가 출력되어 `… + 7 +` 순서가 됩니다.
